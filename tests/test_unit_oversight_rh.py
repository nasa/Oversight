## -*- coding: utf-8 -*-
## Tests for modular input 'oversight' rest handler (generated by splunk ucc-gen)
## and may be modified by additional_packaging.py in project root
import glob
import logging
import operator
import os
import re
import sys
from datetime import datetime, timedelta
from pprint import pprint as pp

import pytest

import tests
from tests import mock_definition

bindir = glob.glob("**/bin", recursive=True)
# hack for making sure we load the ucc-gen build dir
bindir = [i for i in bindir if "output" in i][0]
sys.path.insert(0, bindir)
print(sys.path)

TEST_DIR = tests.TEST_DIR
APP_NAME = tests.APP_NAME

APP_DIR = os.path.join(TEST_DIR, APP_NAME)
BIN_DIR = os.path.join(TEST_DIR, APP_NAME, "bin")

sys.path.insert(0, BIN_DIR)

import import_declare_test
import oversight as lib_rh
import oversight_utils
from splunklib.binding import AuthenticationError, HTTPError


@pytest.fixture(scope="function")
@pytest.mark.no_cover
def test_obj():
    obj = lib_rh.OVERSIGHT()
    pp(obj.__dict__)
    return obj


test_data = [
    (
        {
            "name": "mgmt1",
            "source_expression": "index=foo",
            "id_field": "ip",
            "cron": "1 1 * * *",
        }
    )
]


@pytest.mark.parametrize("input", test_data)
def test_rest_handler_validate_input(input):

    definition = mock_definition(input)
    script = lib_rh.OVERSIGHT()

    assert script.validate_input(definition) == None


test_data = [
    (
        {"name": "mgmt1", "id_field": "ip", "cron": "1 1 * * *"}
    ),  # missing source_expression
    (
        {"name": "mgmt1", "source_expression": "index=foo", "cron": "1 1 * * *"}
    ),  # missing id_field
    (
        {
            "name": "mgmt1",
            "source_expression": "index=foo",
            "id_field": "ip",
            "cron": "1 1 ***",
        }
    ),  # cron syntax should have spaces
    (
        {
            "name": "mgmt1",
            "source_expression": "index=foo",
            "id_field": "ip",
            "inventory_filter": "where foo<5",
            "cron": "1 1 ***",
        }
    ),  # inventory_filter but not inventory_source
    (
        {
            "name": "mgmt1",
            "source_expression": "index=foo",
            "id_field": "ip",
            "enrichment_expression": " eval foo=5",
            "cron": "1 1 * * *",
        }
    ),  # enrichment_expression but no enrichment_fields
    ({"name": "mgmt1", "id_field": "ip", "source_expression": "index=foo"}),
    (  # aggregation_fields but not inventory_source
        {
            "name": "mgmt1",
            "source_expression": "index=foo",
            "id_field": "ip",
            "cron": "1 1 * * *",
            "aggregation_fields": "dns_name, computer_name",
        }
    ),
    (  # invalid cron expression
        {
            "name": "mgmt1",
            "source_expression": "index=foo",
            "id_field": "ip",
            "cron": "1 0 ** *",
        }
    ),
    (  # invalid trailing source_expression |
        {
            "source_expression": "index = foo |",
            "id_field": "host",
            "inventory_source": "1",
            "cron": "0 10 * * *",
        }
    ),
    (  # invalid trailing enrichment_expression |
        {
            "source_expression": "index = foo",
            "id_field": "host",
            "inventory_source": "1",
            "cron": "0 10 * * *",
            "enrichment_expression": ' | eval xy="one"',
        }
    ),
]


@pytest.mark.parametrize("input", test_data)
def test_validate_input_exceptions_raised(input):
    definition = mock_definition(input)
    script = lib_rh.OVERSIGHT()

    with pytest.raises(ValueError):
        print(definition.parameters)
        script.validate_input(definition)


def test_get_scheme_single_instance_mode(test_obj):
    scheme = test_obj.get_scheme()
    print(scheme.__dict__)
    assert scheme.use_single_instance == False


def test_get_schema_no_missing_params(test_obj):
    scheme = test_obj.get_scheme()
    scheme_params = [i.name for i in scheme.arguments]
    scheme_params.remove("name")  # used as stanza name NOT an actual argument
    print(scheme_params)
    inputs_spec_path = os.path.join(
        os.getcwd(), "output/{}/README/inputs.conf.spec".format(APP_NAME)
    )
    with open(inputs_spec_path) as spec_file:
        spec = spec_file.read()
        spec_params = spec.split("\n")[1::]
        spec_params = [i.strip(" =") for i in spec_params]
        assert scheme_params == spec_params
